---
layout: post
title: 台大開放式課程-李宏毅教授-機器學習
categories: [機器學習]
tags: ["NTU class", "AI", "機器學習"]
date: 2023-10-16
excerpt: "從零開始學習機器學習的基礎。"
body_class: post-page
---

# 課程來源
### 網址：
https://www.youtube.com/watch?v=CXgbekl66jc&list=PLJV_el3uVTsPy9oCRY30oBPNLCo89yu49

# ML Lecture 0-1: Introduction of Machine Learning

ai 要做的就是找到一個function (監督式學習)，framework：

## Training Data

1. 準備function set (with million function) which call model
2. training data 可以來測試這個function是否是好的
3. 需要找到一個最好的function去使用達到目標成果

## Testing Data

1. 利用找到的function 去test 找到想要的結果

    介紹了Regresstion, Classification 中的 Binary Classification 以及 Multi-class Classification
Regresstion 有分 liner 以及 Non-liner ，Non-liner 的代表是Deep learning ,SVM , Decision tree , K-nn 等。 

最後是 Structured learing：專門解決一個結構性的問題，像是語音、人臉、語文翻譯
監督式學習的問題是他需要大量的學習資料，Function 輸出的內容被稱為Lable

## 減少DATA的方法

1. Semi-supervised learing (半監督式學習) ：有部分的 labled 的資料以及 部分 unlabled 的資料
2. Transfer learning ：有少量已經labled 的data ，也有另一筆大量的data 不知道有沒有被labled 過，data 裡面的內容可能會跟需要的資料沒什麼關係(e.t.c 學習貓的樣子，data給的是大象)
3. Unsupervised learing ：在沒有lable 的情況下學習

#### Reinforcement learning (強化學習) ： 沒有給機器問題的答案，在學習時不跟他說對不對，而機器會有一個分數去評判自己正不正確。(錯中學)

# ML Lecture 1: Regression - Case Study

1. 線性回歸 (liner regration)，loss function(**損失函數**) 檢查function 有多差
2. 梯度下降 (gradient descent)
    1. tips 1：小心調整 learning rate
3. overfit & reguleration

利用線性回歸來預測寶可夢升級過後的cp值
線性回歸遇到的問題是：

1. 因為函數是一條直線，所以無法包含住所有DATA
2. funtion 準確率不好，提高準確率不會是唯一靈藥
3. DATA 數量太小
4. 大於500CP 的數值變化不一
5. 錯誤率太高
6. overfit

## 減少錯誤率的方法：

1.  利用grafient descent 去找到最好的function，在liner regration 中有convex (凸函數) 可以避免找到不是最佳的結果
2. 增加不同篩選內容以提高正確率(但不一定會是好的)
3. 加入正規化參數在function之中

最後有提到，即使正規化之後testing data 的數值為11.1 ，但是實際運用error應該會更大

可以透過validation (驗證) 來驗證

# ML Lecture 2: Where does the error come from?

### 計算 Bias 跟 Variance 的估計值：
    1. 假設 x 是 μ (估計值)
    2. 假設 x 的Variance 是 $σ$(sigma) 的平方
    
    μ 的估計值：
    
    1. 假設N 有 {x 1次到 x n次方}
        
        M = 1/N ∑nx^n ≠ μ (除非樣本數很大才會等於)
        
    2. if 計算 m 的期望值：(找很多M，其期望值會等於μ)
        
        E[m] = E[1/N ∑nx^n ]=1/N ∑n E[x^n ]=μ (實際值)
        
        //像是打靶一樣，因為風向等因素，所以就算瞄準靶心，還是有可能散布在靶的周圍

圖放反了
![image](https://hackmd.io/_uploads/Bk_03xt4C.png)


    3. 散布的值的計算：
        
        Variance[m] = σ^2/N //變異數依賴於樣本的數量
        
        如果N越多，值就越接近靶心
        
    
    估測 σ^2：
    
    s^2=1/N ∑n (x^n-m)^2
    
    計算 s^2 的期望值：
    
    E[s^2 ]=(N-1)/N σ^2 ≠ σ
    
    如果N越多，值就越接近靶心
![image](https://hackmd.io/_uploads/H1EbpxY4R.png)

    
### 回到regresstion：
    1. 假設靶心叫做 f̂ 
    2. 假設有足夠的N 計算期望值 E[f^* ]= f bar
    
    f̂ (即靶心) 到 f bar 的距離叫做 bias 
    
    f bar 到 f^* 之間叫做 variance
    
    //最期待的狀況是 沒有bias 然後 variance 小
    
    error 來自於兩點：
    
    1. 瞄準的位置在哪裡(有可能沒有bias，但是散布很開)
    2. variance 有多大
    
    if error from variance (很大) called overfitting
    
    if error from bias (很大) called underfitting

![image](https://hackmd.io/_uploads/BJ9myZFNR.png)

    
### 如何判斷 how to diagnosis
    1. if your model cannot even fit the traning examples，then you have large bias (underfitting)
    2. if you can fit the training data, but large error on testing data, you probably have large variance (overfitting)
    
    Redesign model：
    
    Underfitting → 增加更多的特徵、使用更複雜的模型
    
    Overfitting → 增加更多data (很有效但是不實際) 、正規化 (可能會傷害到bias，因為要讓曲線更平滑)
    
### Model Selection
    1. 在 bias 跟 variance 之間找到平衡
    2. 選擇 bias 跟 variance都是最小的 model
    
    不該做的事： (it's for homework)
    
    利用透過training set 的model 測試testing set 的資料 ，其結果的錯誤率會 > real world 

public set 的結果不可靠 他有可能在public排名第一，但在 real world 排名40幾
![image](https://hackmd.io/_uploads/rk8sebYN0.png)

    怎麼做呢：
    
    1. 將Training set 分成 Training set 、 Validation set 
    2. 如果不放心可以再將最好的結果，再去與最開始還沒分開的Training set 再train 一次
    3. 這時候testing set 的error 會 > 0.5，但是real world 也同樣會 > 0.5
    4. 不建議將testing set 之後的資料丟回Training set ，因為這樣會再將 testing set 的 bias 考慮進去，出來的結果就不能映射出real world 的結果 (即，第三點)
### N-fold Cross Validation
    
    如果害怕 training set 、 validation set 分壞
    
    可以將training set 分成三塊 ，如：train、train 、val，再將這三塊丟去三個模組，算出error 值，之後再算出平均error 值，接著選出最低的平均值之後，再丟回原本大的 Training Set (未被分塊的) ， train完之後再丟testing set 跟 real world
    
    |  | Traing Set |  |
    | --- | --- | --- |
    | Train | Train | Val |
    | Train | Val | Train |
    | Val | Train | Train |
    
    | Model 1  | Model 2  | Model 3  |
    | --- | --- | --- |
    | Err = 0.2 | Err = 0.4 | Err = 0.4 |
    | Err = 0.4 | Err = 0.5 | Err = 0.5 |
    | Err = 0.3 | Err = 0.6 | Err = 0.3 |
    | Avg Err | Avg Err | Avg Err |
    | = 0.3 | = 0.5 | = 0.4 |
    
# ML Lecture 3-1: Gradient Descent

## Tips1：

1. 通常 learning rate 會隨著參數的更新越來越小 (但是基本上不固定)

![image](https://hackmd.io/_uploads/SkxOlo_V0.png)

2. 通常在一開始的起始點，learning rate 會離原點很遠 ()
3. 經過幾次調整，應該要減少learning rate 讓他可以收斂在最低點的地方

learnig rate cannot be one-size-fits-all

給每個參數不同learning rate

### Adagrad(有人說他慢到令人髮指)：

每一個learning rate 除上過去所有微分值的root mean square(平方平均根)，所以每個參數都不一樣

1. g^t=(delC(Θ^t))/delw (del 是偏微分)
2. η^t=η/√(t+1)

### Vanilla Gradient descent：

w^(t+1)<-w^t-η^t g^t

![image](https://hackmd.io/_uploads/HkWTuc3NC.png)

### Adagrad (最簡單的方法)：

w^(t+1)<-w^t-η^t/σ^t g^t 

![image](https://hackmd.io/_uploads/HyrpUq2V0.png)

// σ^t ：root mean square of the previous derivatives of parameter w

#### 下面為示範：

| w^1<-w^0-η^0/σ^0 g^0  | σ^0 = √(g^0)^2 |
| --- | --- |
| w^2<-w^1-η^1/σ^1 g^1  | σ^0 = 1/2√[(g^0)^2+(g^1)^2] |
| w^3<-w^2-η^2/σ^2 g^2 | σ^0 = 1/2√[(g^0)^2+(g^1)^2+(g^2)^2] |
| w^(t+1)<-w^t-η^t g^t | σ^t=√[(1/(t-1) ∑ (i=0)^t (g^i)^2 )] |

然而η^t 跟 σ^t 都有一個 √(t-1)，所以公式變成這樣：

w^(t+1)<-w^t-η/√(∑(i=0)^t〖(g^i)〗^2 ) g^t
![image](https://hackmd.io/_uploads/SkNND52N0.png)

#### question：

分母的 √(∑(i=0)^t〖(g^i)〗^2 ) 與 分子的g^t 產生反差 (直觀的解釋)

![image](https://hackmd.io/_uploads/BJYO_q3E0.png)

gradient 的值越大就離最小值越遠

正式的解釋：

1. 假設一個圖 ： y= ax^2 + bx + c ，最低點為 - b / 2a
2. 要做 gradient descent 的情況下，假設一個點 x

踏出去最好的步伐是 |x + b / 2a| → |2ax + b| / 2a ，就是x 的一次微分

1. 踏出去的大小會與x 的值成正比，他會是最好的步伐
2. 只能考慮在只有一個參數時才成立

#### 在多個參數時：

一個參數時，函數要除2a ，而2a 是函數做2次微分的結果

1. 最好的step 不只要正比於一次微分，還要與二次微分的大小成反比

the best step is |First derivative| / second derivative

## Tips 2：

1. Stochastic (隨機) Gradient Descent (SGD) 
    
    ![Gradient Descent](https://hackmd.io/_uploads/H1NVlGNE0.png)

    
    Gradient Descent
    
    ![Loss function](https://hackmd.io/_uploads/r1eLyzNEA.png)

    
    Loss function
    
    1. 取一個 example x^n (可以隨機選，也可以指定選)
    2. 利用取的值計算 loss function (只針對取的那個值)
    3. updata 參數時只考慮那一個 example
    4. 每有一個參數就updata一次
    

## Tips 3：

1. Feature Scaling (**特徵縮放**)
    
    假設 y = b + w1x1 + w2x2
    
    ![make different feature have the same scaling](https://hackmd.io/_uploads/Syi_kMV40.png)
    
    make different feature have the same scaling
    
    ![解釋：提高準確性，讓function變簡單](https://hackmd.io/_uploads/S1mqyzVN0.png)
    
    解釋：提高準確性，讓function變簡單
    
2. how to do scaling
    1. 一種常見的做法
        1. 每一個 dimension i 算出 mean (平均數)(mi)，算出他的 standard deviation (標準差)(σi)
        2. 對第r 項的第i 減去所有data 的第i 的 mean 除上所有data 的第i 的  standard deviation
            
            ![Untitled 4](https://hackmd.io/_uploads/ryWMeMVNC.png)

            
        3. 會得到所有dimension 的mean 會是 0 ， 所有 variances 會是 1
3. Gradient Descent 
    1. 當函式只有一項
        
        ![Untitled 5](https://hackmd.io/_uploads/rkHSgGVVR.png)

        
        Taylor series：
        
        用於尋找在圓內，圓心到最近的圓周的距離
        
        ![只考慮input 一個variable 的case](https://hackmd.io/_uploads/S1aIgGNEC.png)

        
        只考慮input 一個variable 的case
        
    2. 當函式不只一項
        
        ![考慮input 2個variable 的case](https://hackmd.io/_uploads/ryFdgMVER.png)

        
        考慮input 2個variable 的case
        
        Multivariable Taylor series：
        
        尋找圓心到圓周的距離，即(u,v) 的相反
        
        ![考慮有(x,y) 的情況](https://hackmd.io/_uploads/Hk8ogzENC.png)

        
        考慮有(x,y) 的情況
        
        ![Untitled 9](https://hackmd.io/_uploads/BJXnlGE4A.png)

        
        若將函式帶入：
        
        此式的成立標準為，learning rate 足夠精確 (或是說足夠小)
        
        ![Untitled 10](https://hackmd.io/_uploads/B1WpxMN4A.png)

        
4. The limitation of Gradient Descent 
    1. 在偏微分時，值等於0 → local minima (後面可能還有更小的值，但是被侷限住了)
    2. 在更前面時也會有值等於0 → saddle point (鞍點)
    3. 也有可能在更更前面時遇到偏微分的值約等於0 (較常見) 
        
        plateau n. **高原**
        
        ![image](https://hackmd.io/_uploads/S1ExZGVE0.png)

# ML Lecture 4: Classification

Input : X → Classification → Output：Class n 

1. How to do classification?
    1. just use the same way as regression
        
        ![對於classification 這個分類是好的，左邊要偏向 -1 , 而右邊要偏向正 1 ](https://hackmd.io/_uploads/HJ2DZGEER.png)

        
        對於classification 這個分類是好的，左邊要偏向 -1 , 而右邊要偏向正 1 
        
        ![右邊有一組特別大的數據，紫色那條函數可以讓那組數據更接近於1，不然對於綠色那條函數來說，這組數據是error](https://hackmd.io/_uploads/H11P-GN4C.png)

        
        右邊有一組特別大的數據，紫色那條函數可以讓那組數據更接近於1，不然對於綠色那條函數來說，這組數據是error
        

2. Ideal Alternative

![對於loss function來說，training data 的到錯誤的次數要越小越好。也就是說f function 不等於 y hat n 的整個function 等於 1](https://hackmd.io/_uploads/H1-qbzEER.png)
對於loss function來說，training data 的到錯誤的次數要越小越好。也就是說f function 不等於 y hat n 的整個function 等於 1

3. Generative Model
    
    紅色框框得4個參數要利用training data 來計算
    
    ![尋找 x 在 c1 或是 c2 的機率哪個比較大](https://hackmd.io/_uploads/Hk51zMN4R.png)

    
    尋找 x 在 c1 或是 c2 的機率哪個比較大
    
4. Prior (事先的)
    
    ![計算機率](https://hackmd.io/_uploads/HJsgzM4VR.png)

    
    計算機率
    
5. Gaussian Distribution (常態分布)
    
    如果今天要在training data 裡面找一個點 x，可以用這個方法
    
    透過找到 μ,Σ 去計算出常態分佈 (就是與離紅色圓心的距離，越遠數值越大)
    
    ![Output 找到 x 的機率 (這裡是與機率成正比的值，他其實不算是機率，只是講機率比較容易懂)](https://hackmd.io/_uploads/rJ4QGGNNC.png)

    
    Output 找到 x 的機率 (這裡是與機率成正比的值，他其實不算是機率，只是講機率比較容易懂)
    
6. Maximum likelihood (**最大概似估計)**
    
    尋找 μ,Σ 的方法
    
    1. 先用公式算出所有機率，並把他乘起來。
        
        ![Untitled 6](https://hackmd.io/_uploads/Syw4MG4VC.png)

        
    2. 將 μ,Σ 帶入機率去找到最大值
        
        ![Untitled 7](https://hackmd.io/_uploads/ByI8MGN4C.png)

        
7. 將上面結合起來
    
    ![之後試了成功率最高只有到54%](https://hackmd.io/_uploads/By6ufGEV0.png)

    
    之後試了成功率最高只有到54%
    
8. Modify model (調整模型)
    
    ![把總數變成共通的來計算](https://hackmd.io/_uploads/SJOnzfEEA.png)


    
    把總數變成共通的來計算
    
    ![左圖為原本的演算法，右圖為調整過的演算法](https://hackmd.io/_uploads/Skt0fMNNR.png)


    
    左圖為原本的演算法，右圖為調整過的演算法
    
9. Posterior Probability (**事後機率**)
    
    ![處理前的式子](https://hackmd.io/_uploads/BJ0_QG4NC.png)
    
    處理前的式子
    
    ![目的是找出 w , b (後面的課程會說直接找出這兩個的方法)](https://hackmd.io/_uploads/HJQo7fVE0.png)

    
    目的是找出 w , b (後面的課程會說直接找出這兩個的方法)
    
    ![結論](https://hackmd.io/_uploads/Sk_3mM4ER.png)
    結論

# ML Lecture 5: Logistic Regression

1. Step one Function Set：
    
    直接算出 w,b 的值
    
    ![完整算式在前一課](https://hackmd.io/_uploads/Hy6-EGVER.png)

    
    完整算式在前一課
    
2. Step two goodness of a function：
    
    前面基本上都在算式推倒
    
    ![我們要求的東西，下面那張圖是算式推倒的結果](https://hackmd.io/_uploads/rygN4M44C.png)

    
    我們要求的東西，下面那張圖是算式推倒的結果
    
    ![cross entropy (交叉**熵**) 在算 p,q 的接近程度，如果很接近，值就是0](https://hackmd.io/_uploads/SJuUVfENC.png)
   
    cross entropy (交叉**熵**) 在算 p,q 的接近程度，如果很接近，值就是0
    
3. logistic vs linear
    
    ![image](https://hackmd.io/_uploads/ByhdEfNVR.png)

    
    logistic 的 loss function 要做的就是想辦法讓cross  entropy 接近0
    
4. Step three Find the best function
    
    一樣前面基本上都是公式推倒，最後式子會變成跟最下面那個一樣
    
    ![y hat n 是目標](https://hackmd.io/_uploads/rJJ24fNNR.png)

    
    y hat n 是目標，f of x 是目前model 的output，相減的差等於，兩者差距有多大
    
5. logistic vs linear - 2
    
    ![image](https://hackmd.io/_uploads/SkxVDH6V0.png)

    基本上一樣(gradient desent 的部分)，差別在於 logistic 介於 0、1 之間
    
    ![Untitled 5](https://hackmd.io/_uploads/ry2ZYfNE0.png)

    
6. logistic regression + square error
    
    如果將logistic 跟做 liner 一樣的方式
    
    簡單來說，不會使用square error(mean-square error、MSE)，因為微分之後會分不出來他是靠近的那個值，還是很遠的值
    
    他有可能會離得很遠，但是微分值是0，也可能會很近，微分值同樣是0
    
    ![image](https://hackmd.io/_uploads/HJkX5f4EC.png)


    
7. Discriminative vs **Generative (判別 vs 生成)**
    
    問題：兩個找出的 w,b 會是同一組資訊嗎?
    
    答案：兩組不同，因為在logisitc 裡面沒有做假設，但在 linear 有做假設，像是常態分佈等
    
    ![左邊是 logistic，右邊是linear](https://hackmd.io/_uploads/SyMUcG4N0.png)

    
    左邊是 logistic，右邊是linear
    
8. Generative vs Discriminative
    
    Discriminative 因為沒有做任何事先假設，所以data的數量會對他有很大的影響
    
    Generative 因為有自己的假設，他有時候會無視data，自己腦補一個結果
    
    ![data小 → generative > discriminative](https://hackmd.io/_uploads/H1LdqGNEA.png)


    
    data小 → generative > discriminative
    

9.  Multi-class classification

z1~z3 → 總數 → 除上 ez1~3 → y1~3

![image](https://hackmd.io/_uploads/rkn9qMVNC.png)


準確來說

![image](https://hackmd.io/_uploads/r133cM4NR.png)


1. Limitation of Logistic regression
    1. 假設問題：
        
        我們要將紅色的點和藍色的點用 linear regression 分開
        
        但是會遇到問題
        
        ![image](https://hackmd.io/_uploads/BJoRcGVVR.png)

        
        出來的function是不理想的
        
        ![image](https://hackmd.io/_uploads/H1AxizVE0.png)

        
    2. 問題解決 (1)：feature transformation （特徵轉換）
        
        但是不是每一次都有辦法很容易的做feature transformation
        
        而且就算真的build出來，那也不算人工智慧了，那是人的智慧
        
        ![image](https://hackmd.io/_uploads/HyYQiMNEC.png)

        
    3. 問題解決 (2)：Cascading Logistic Regression
        
        假設x1、x2 兩個 logistic regression model，
        
        x1*w + x2*w → z1(sigmoid function) ，變成x1’
        
        後面同理。
        
        接著再將 x1’ , x2’  接到另一個 sigmoid function z → y
        
        ![Untitled 14](https://hackmd.io/_uploads/rkO4iM4E0.png)

        
        可以透過控制w 去控制裡面的數字
        
        ![image](https://hackmd.io/_uploads/SkRrsfNVR.png)

        
        最後的圖變成這樣
        
        ![x1’ 跟 x2’ 畫反了](https://hackmd.io/_uploads/SkFDjMENC.png)

        
        x1’ 跟 x2’ 畫反了
        
    
    結論：
    
    我們可以將多個 logistic regression 組起來，
    
    它可以是別的 logistic 的output ，或input
    
    這樣的一個 logistic regression 就被稱作 Neuron (類神經)
    
    多個串在一起就叫做 Neural Network (類神經網路)
    
    ![Untitled 17](https://hackmd.io/_uploads/BksFsfN40.png)

# ML Lecture 6: Brief Introduction of Deep Learning

1. Fully connect feedforword network
    
    ![跟上一課一樣，透過logistic regression 去計算](https://hackmd.io/_uploads/Hy-B3MNEC.png)
    
    跟上一課一樣，透過logistic regression 去計算
    
    input 不算是一個 layer，但還是把他當作layer看待
    
    ![image](https://hackmd.io/_uploads/BJ5vnMNNC.png)
    
    Deep = many hidden layers
    
2. Matrix operation
    
    ![image](https://hackmd.io/_uploads/rySYhfVEC.png)

    
3. Neural network
    
    ![利用電腦科學去加快矩陣運算的速度](https://hackmd.io/_uploads/rySsnG4NR.png)

    
    利用電腦科學去加快矩陣運算的速度
    
4. Output layer
    
    output layer 利用前面的hidden layers 當作feature ，透過softmax 變成 y
    
    ![hidden layers 擷取特徵並替換特徵](https://hackmd.io/_uploads/HJHahf4NR.png)

    
    hidden layers 擷取特徵並替換特徵
    
5. FQA 
    (足跡，錯誤+直覺)
    
    ![image](https://hackmd.io/_uploads/rJVJTf4EA.png)

    
6. loss of example
    
    ![做法跟multi-class 一樣](https://hackmd.io/_uploads/BkFWTMVV0.png)

    
    做法跟multi-class 一樣
    
7. Total loss
    
    ![image](https://hackmd.io/_uploads/HJI7afVNC.png)
    
8. 如何找到 θ* 的total loss
    
    ![除了函式變比較複雜以外，跟前面教的一樣](https://hackmd.io/_uploads/rkCNpM4EC.png)
    
    除了函式變比較複雜以外，跟前面教的一樣
    
9. Backpropagation
    
    ![就是算微分的工具](https://hackmd.io/_uploads/Sy-wTfVVA.png)

    就是算微分的工具
    
# ML Lecture 7: Backpropagation

前一課有提到，他是拿來幫你算偏微分的東西(X)
(反向傳播算法)
藉由微積分上的鏈鎖率可以從神經網路的末端開始計算誤差與各權重的關係，藉此減少運算量。

1. Gradient Descent
    
    ![只是個較有效率的演算法](https://hackmd.io/_uploads/B1YACfV4C.png)

    
    只是個較有效率的演算法
    
2. Chain rule (唯一要記的東西)
    
    ![image](https://hackmd.io/_uploads/BkqgyQ440.png)

    
3. Backpropagation
    
    後面會針 Cn 對 w 的微分怎麼做
    
    ![Cn 是 yn 與 yn hat 的距離](https://hackmd.io/_uploads/BJ1MyQNNC.png)

    Cn 是 yn 與 yn hat 的距離
    
    ![image](https://hackmd.io/_uploads/SJADkXVER.png)

    
4. forward pass
    
    ![它有個規律，它前面是什麼，微分就是甚麼](https://hackmd.io/_uploads/B1y9kX4VR.png)

    
    它有個規律，它前面是什麼，微分就是甚麼
    
5. backward pass
    
    ![假裝自己知道面的問號，前面就可以很容易算出來](https://hackmd.io/_uploads/S1cnk7VNC.png)

    
    假裝自己知道前面的問號，前面就可以很容易算出來
    
    ![所以要算的是∂C / ∂z](https://hackmd.io/_uploads/BydRJXN40.png)

    
    所以要算的是∂C / ∂z
    
    ![如果下一個 neural 就是 output ，那就可以直接算](https://hackmd.io/_uploads/H1CzxQ44R.png)

    
    如果下一個 neural 就是 output ，那就可以直接算
    
    ![如果後面還有很多layer ，那要一直到output layer 有辦法算得出來](https://hackmd.io/_uploads/B1nHxX4NR.png)

    
    如果後面還有很多layer ，那要一直到output layer 有辦法算得出來
    
    ![但其實可以直接去找output layer 去算](https://hackmd.io/_uploads/HJDPxmVVC.png)

    
    但其實可以直接去找output layer 去算
    
6. summary
    
    ![Untitled](https://hackmd.io/_uploads/BJ2ugQE4A.png)

# ML Lecture 8-1: “Hello world” of deep learning

Keras

1. define a set function
    
    ![image](https://hackmd.io/_uploads/rylCgQVVC.png)
    
2. goodness of function
    
    ![image](https://hackmd.io/_uploads/SJ7eZQ44R.png)
    
3. pick a best function
    1. 3.1
        
        ![image](https://hackmd.io/_uploads/BkXM-XENA.png)
        
    2. 3.2
        
        ![image](https://hackmd.io/_uploads/By_QWQ4VR.png)
        
    3. batch_size
        
        在做deep learning 時，我們不會真的minimize total loss，我們會將隨機的資料分成一個一個不同的batch
        ![image](https://hackmd.io/_uploads/r1ZrbQNVA.png)
        
    4. 3.3
        
        ![隨機gradient descent 的優勢是跑比較快](https://hackmd.io/_uploads/SJewbXEVA.png)

        隨機gradient descent 的優勢是跑比較快
        
    
    4. Speed
    
    因為利用了平行運算，所以會跑比較快
    
    但不該將值設很大，因為會卡住，就算跑得動，結果也會很差
    
    ![image](https://hackmd.io/_uploads/B1mcZ7NEA.png)
    
    1. 比較
        
        ![下面會比較快，上面的時間反而會變成他的兩倍](https://hackmd.io/_uploads/SkUoZ7VNR.png)
        
        下面會比較快，上面的時間反而會變成他的兩倍
        
    2. how to use
        
        ![image](https://hackmd.io/_uploads/rkpnZm4VC.png)

# ML Lecture 8-2: Keras 2.0

改版後的Keras

跟上一課一樣，只是有一些參數的名稱不一樣

# ML Lecture 9-1: Tips for Training DNN

1. Recipe of deep learing
    1. 定義一個好的function set
    2. 決定 loss function
    3. 做 gradient descent
    
    ![image](https://hackmd.io/_uploads/ry7HGXVV0.png)
    
2. do not always blame overfitting
    1. 在 training 時可能會有很多問題才讓結果變成這樣(只for neural network)
    2. 所以他不是overfitting，只是沒有training好
    
    ![image](https://hackmd.io/_uploads/B1kifXNNC.png)
    
3. 架構設計是不是不好
    1. 不同的問題要對致不同的解決方法
    
    ![image](https://hackmd.io/_uploads/S1HnGXE4A.png)
    
    ![sigmoid function發生的問題](https://hackmd.io/_uploads/SJzy7X4ER.png)
    
    sigmoid function發生的問題
    
4. vanish gradient problem

    在每次訓練的迭代中，神經網路權重的更新值與誤差函數的偏導數成比例，然而在某些情況下，梯度值會幾乎消失，使得權重無法得到有效更新，甚至神經網路可能完全無法繼續訓練。
    
    ![image](https://hackmd.io/_uploads/B1XW7m4VC.png)
    
    ![解說：一開始的w很大，經過神經元之後到後面就會越來越小](https://hackmd.io/_uploads/HJ5EX7VV0.png)
    
    解說：一開始的w很大，經過神經元之後到後面就會越來越小
    
    解決問題：
    
    ![image](https://hackmd.io/_uploads/H1DwXQVE0.png)

    ![因為有很多nerual等於0，所以被消掉，之後就變成這樣](https://hackmd.io/_uploads/HyQYXXVNA.png)
    
    因為有很多nerual等於0，所以被消掉，之後就變成這樣
    如果input > 0 input = output
    input < 0 output = 0
    所以他就變成linear了
    
5. Maxout
    1. 他可以讓network 自己學 actiation function
    
    ![image](https://hackmd.io/_uploads/BJzi77NNC.png)

    ![image](https://hackmd.io/_uploads/S1Un7XNNR.png)

    ![image](https://hackmd.io/_uploads/B1DCXmE40.png)

6. how to training
    
    ![找比較大的element](https://hackmd.io/_uploads/SJLlEXVEC.png)
    
    找比較大的element
    
    看似都被去掉，但其實每筆資料都還是會被train到
    
    ![它會變成這樣](https://hackmd.io/_uploads/S1OGNQEEA.png)
    
    它會變成這樣
    
7. 無法利用adagrem去解決這個問題(learning rate problem)
    我們現實中常會碰到的 Loss function 並非都是平穩、簡單的，甚至絕大多數我們遇到的 Error surface 都非常複雜。
    
    ![image](https://hackmd.io/_uploads/ByMEVXVEA.png)

    RSMprop
    如上圖，即使在同一個維度上，學習率都有可能必須要能夠快速的反應、變動，因此提出了這個新的優化方式
    他在調整learning rate 上面多了一個參數α，可以在新舊梯度上面做調節
    若α上調，便對於舊的梯度有更大的佔比，也就是說在整個調節的過程中較傾向相信舊梯度帶給我們的資訊。
    
    ![image](https://hackmd.io/_uploads/HkMD4X4VA.png)

8. (稍微)解決 local minima 的問題(momentum)
    
    ![藍色加紅色](https://hackmd.io/_uploads/BkFtNX4ER.png)

    綠色是慣性的方向，紅色是gradient，藍色是最後算出來的local minima
    
    ![image](https://hackmd.io/_uploads/SJCcNXVE0.png)

9. RMSprop + momentum
    
    ![image](https://hackmd.io/_uploads/SkgyB7NNR.png)

10. 在training data 得到夠好的結果 ，但是在testing data上不夠好
    
    ![image](https://hackmd.io/_uploads/HJKxBmE4R.png)

    Early Stopping：
    如果我們可以知道testing set 的情況，我們應該要在testing set 的最低點停下，而不是training set
    但我們不會知道，所以通常都是先在validation set 上知道
    
    ![image](https://hackmd.io/_uploads/rklzB7E4C.png)

    Regularization：
    重新定義我們要minimized 的 loss function
    假如參數太大，雖然可以順利的辨認"訓練資料"
    但遇到真實資料時很容易就把真實資料的 noise 放大，就形成了 Overfitting
    所以我們必須限制參數大小，防止過擬和
    
    ![正規化是為了增加 smoothing , 不考慮biases因為不怎麼影響](https://hackmd.io/_uploads/r14VSXVEA.png)

    正規化是為了增加 smoothing , 不考慮biases因為不怎麼影響
    
    ![L2 正規化，通常都有很多很小很小得值；L2固定乘上一個小餘1固定的值](https://hackmd.io/_uploads/SkwLBXN4A.png)

    L2 正規化，通常都有很多很小很小得值；L2固定乘上一個小餘1固定的值
    
    ![L1 正規化，是正的就是1，副的就是0，畫底線那裏；通常L1都會減去固定的值(或是加)](https://hackmd.io/_uploads/SJO_HmENR.png)
    
    L1 正規化，是正的就是1，副的就是0，畫底線那裏；通常L1都會減去固定的值(或是加)
    
    1. Drop out
        
        ![每一次每個element會有P%的機率被丟掉](https://hackmd.io/_uploads/B1EqH7ENC.png)
        
        每一次每個element會有P%的機率被丟掉
        
        ![神奇的0.5](https://hackmd.io/_uploads/Byn6BmVV0.png)
        
        神奇的0.5
        
        為什麼dropout有用：
        
        1. 直覺的想法
            
            ![image](https://hackmd.io/_uploads/H10y8XNVC.png)

        2. 大家都以為對方會擺爛，所以大家都做的很努力
            
            ![image](https://hackmd.io/_uploads/rJLWImNVA.png)

        3. 如果再training的時候假設有50%被dropout，在Testing 的時候數值就會是他的2倍
            
            這時候再乘上0.5倍才合理
            ![image](https://hackmd.io/_uploads/HkOmUQNVC.png)

        4. one of 文獻的方法 ensemble
            
            ![training很多不同 model ](https://hackmd.io/_uploads/ByzSUXEEA.png)
            
            training很多不同 model 
            
            ![在testing data 過後將結果平均起來(just like readom forest)](https://hackmd.io/_uploads/rkXPUm4VR.png)

            在testing data 過後將結果平均起來(just like readom forest)
            ![image](https://hackmd.io/_uploads/ryDtUXVNA.png)

# ML Lecture 20: Support Vector Machine (SVM)

1. 組成
    
    ![Untitled](https://hackmd.io/_uploads/Hk9nU7NVR.png)
    
2. loss function
    
    ![由於它不能微分，所以用另一個式子](https://hackmd.io/_uploads/HyANPmE4A.png)
    
    由於它不能微分，所以用另一個式子
    
    ![square loss 不合理](https://hackmd.io/_uploads/HylwDmNVA.png)

    square loss 不合理，因為資料越大，loss應該越小
    
    ![square loss 不好(不想努力沒有回報)](https://hackmd.io/_uploads/HJR_vXN4C.png)
    
    sigmoid + square loss 不好(不想努力沒有回報)
    like: -2 到 -1 移動很小
    
    ![這個合理(努力可以得到回報)](https://hackmd.io/_uploads/ByMjPXEVC.png)

    
    sigmoide + cross entropy這個合理(努力可以得到回報)
    like: -2 到 -1 移動很大
    
    ![hinge loss 是主旨](https://hackmd.io/_uploads/S1zRwX4N0.png)
   
    當 y n hat * f of x > 1 時就很好了，再多不會變的更好
    如果小於1 就不夠好
    
3. Linear SVM
    
    ![它與 logistic 的差別在於 hinge loss ，所以它也可以有deep的版本](https://hackmd.io/_uploads/HkueOQ4V0.png)

    
    它與 logistic 的差別在於 如何訂定loss function ，所以它也可以有deep的版本
    
4. SVM  also - gradient descent
    
    ![image](https://hackmd.io/_uploads/HJszdXENA.png)

5. ξn 不能是負數
    
    ![image](https://hackmd.io/_uploads/ByH4dQN40.png)

6. Dual representation
    
    ![公式推演](https://hackmd.io/_uploads/SkH8dXVVR.png)
    
    公式推演
    
    ![公式推演](https://hackmd.io/_uploads/H1gddQV40.png)
    
    公式推演
    
    Kernel Trick(將資料由非線性投影將他們在更高維度可以區分開來)：
    
    ![image](https://hackmd.io/_uploads/HyQ9_QNNA.png)
    
    How to use Kernel Trick：
    
    ![Untitled 12](https://hackmd.io/_uploads/BJCsO7V4R.png)

    Radial Basis Function Kernel (用泰勒級數推倒投影函數)：
    
    ![在無窮多維的平面上做事情(很容易overfitting)](https://hackmd.io/_uploads/BkPp_74VA.png)

    
    在無窮多維的平面上做事情(很容易overfitting)
    
    Sigmoid Kernel：
    
    ![Untitled 14](https://hackmd.io/_uploads/rJebt7VN0.png)
    
    ![image](https://hackmd.io/_uploads/S18CMvTVR.png)
    https://hackmd.io/@allen108108/r1ycwIh-H#4-Sigmoid-Kernel--KxxtanhxTx
    
    1. Deep Learning vs SVM
        
        ![Untitled 16](https://hackmd.io/_uploads/rJOMtXNVC.png)

